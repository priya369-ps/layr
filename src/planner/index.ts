import * as vscode from 'vscode';
import { ProjectPlan, LayrConfig, PlanGenerator, APIKeyMissingError, AIServiceError, AIProvider, AIProviderType } from './interfaces';
import { GeminiPlanGenerator } from './ai';
import { RuleBasedPlanGenerator } from './rules';
import { getAIProviderFactory } from './providers';

/**
 * Main planner class that orchestrates plan generation
 */
export class Planner {
  private aiProvider: AIProvider | null = null;
  private ruleGenerator: RuleBasedPlanGenerator;
  private config: LayrConfig;
  private aiModel!: string;

  constructor() {
    // ONLINE ONLY MODE: Disable rule-based generator
    this.ruleGenerator = new RuleBasedPlanGenerator();
    this.config = this.loadConfig();
    this.initializeAIProvider();
    
    console.log('Planner: ONLINE ONLY MODE - Offline templates disabled');
  }

  /**
   * Generate a project plan from a natural language prompt - ONLINE ONLY MODE
   */
  async generatePlan(prompt: string): Promise<ProjectPlan> {
    console.log('Planner.generatePlan: ONLINE ONLY MODE - Starting plan generation');
    
    // Force refresh config to ensure we have the latest API key
    this.refreshConfig();
    
    console.log('Planner.generatePlan: AI provider exists:', !!this.aiProvider);
    console.log('Planner.generatePlan: AI provider type:', this.aiProvider?.type || 'none');
    
    // REQUIRE AI provider - no offline fallback allowed
    if (!this.aiProvider) {
      const errorMsg = 'ONLINE MODE REQUIRED: No AI provider initialized. Please configure your API key in VS Code settings or .env file.';
      console.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg);
      throw new APIKeyMissingError();
    }

    const isAvailable = await this.aiProvider.isAvailable();
    console.log('Planner.generatePlan: AI provider available:', isAvailable);
    
    if (!isAvailable) {
      const errorMsg = `ONLINE MODE REQUIRED: AI provider (${this.aiProvider.name}) not available. Please check your API key configuration.`;
      console.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg);
      throw new APIKeyMissingError();
    }

    try {
      console.log('Planner.generatePlan: Attempting AI plan generation with', this.aiProvider.name);
      const planText = await this.aiProvider.generatePlan(prompt);
      console.log('Planner.generatePlan: AI plan generation successful');
      console.log('Planner.generatePlan: Raw response length:', planText.length);
      console.log('Planner.generatePlan: Raw response preview:', planText.substring(0, 200));
      
      // Parse the plan text into a ProjectPlan object
      const plan = this.parseAIPlan(planText);
      vscode.window.showInformationMessage(`Plan generated by ${this.aiProvider.name}! ðŸ¤–`);
      return plan;
    } catch (error) {
      console.error('Planner.generatePlan: AI plan generation failed:', error);
      
      let errorMessage = 'ONLINE MODE REQUIRED: AI plan generation failed. ';
      if (error instanceof APIKeyMissingError) {
        errorMessage += `Please configure your ${this.aiProvider?.name || 'AI provider'} API key.`;
      } else if (error instanceof AIServiceError) {
        errorMessage += `AI service error: ${error.message}`;
      } else {
        errorMessage += 'Unexpected error with AI service.';
      }
      
      vscode.window.showErrorMessage(errorMessage);
      throw error; // Re-throw the error instead of falling back to offline mode
    }
  }

  /**
   * Convert a ProjectPlan to Markdown format
   */
  planToMarkdown(plan: ProjectPlan): string {
    const markdown = [];
    
    // Header
    markdown.push(`# ${plan.title}`);
    markdown.push('');
    markdown.push(`*Generated by Layr on ${plan.generatedAt.toLocaleDateString()} at ${plan.generatedAt.toLocaleTimeString()}*`);
    markdown.push('');

    // Overview
    markdown.push('## Overview');
    markdown.push(plan.overview);
    markdown.push('');

    // Requirements
    markdown.push('## Requirements');
    plan.requirements.forEach(req => {
      markdown.push(`- ${req}`);
    });
    markdown.push('');

    // File Structure
    markdown.push('## File Structure');
    markdown.push('```');
    this.renderFileStructure(plan.fileStructure, markdown, 0);
    markdown.push('```');
    markdown.push('');

    // Next Steps
    markdown.push('## Next Steps');
    plan.nextSteps.forEach((step, index) => {
      const checkbox = step.completed ? '[x]' : '[ ]';
      const priority = step.priority === 'high' ? 'ðŸ”´' : step.priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      const time = step.estimatedTime ? ` (${step.estimatedTime})` : '';
      markdown.push(`${index + 1}. ${checkbox} ${priority} ${step.description}${time}`);
      
      if (step.dependencies && step.dependencies.length > 0) {
        markdown.push(`   - *Depends on: ${step.dependencies.join(', ')}*`);
      }
    });
    markdown.push('');

    // Footer
    markdown.push('---');
    markdown.push('*Generated by Layr - AI Planning Layer for VS Code*');

    return markdown.join('\n');
  }

  /**
   * Refresh configuration and reinitialize AI provider
   */
  refreshConfig(): void {
    this.config = this.loadConfig();
    this.initializeAIProvider();
  }

  /**
   * Debug method to check if AI provider is available
   */
  async isAIAvailable(): Promise<boolean> {
    return this.aiProvider !== null && await this.aiProvider.isAvailable();
  }

  /**
   * Debug method to test the API key
   */
  async testAPIKey(): Promise<{ success: boolean; error?: string }> {
    if (!this.aiProvider) {
      return { success: false, error: 'AI provider not initialized' };
    }
    try {
      const isValid = await this.aiProvider.validateApiKey(this.getApiKeyForProvider());
      return { success: isValid };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  private loadConfig(): LayrConfig {
    const config = vscode.workspace.getConfiguration('layr');
    
    // Load unified model setting
    this.aiModel = config.get<string>('aiModel') || 'gemini-2.5-flash';
    
    // Determine provider from model name
    let aiProvider: AIProviderType = 'gemini';
    if (this.aiModel.startsWith('gemini')) {
      aiProvider = 'gemini';
    } else if (this.aiModel.startsWith('gpt') || this.aiModel.startsWith('o3')) {
      aiProvider = 'openai';
    } else if (this.aiModel.startsWith('claude')) {
      aiProvider = 'claude';
    } else if (this.aiModel.startsWith('kimi') || 
               this.aiModel.startsWith('deepseek') || 
               this.aiModel.startsWith('grok')) {
      aiProvider = 'openai'; // Default to OpenAI for other models
    }
    
    const apiKey = config.get<string>('apiKey') || '';
    const openaiOrganization = config.get<string>('openaiOrganization') || '';
    
    // Map to provider-specific configurations with fallbacks to environment variables
    const geminiApiKey = aiProvider === 'gemini' ? apiKey : process.env.GEMINI_API_KEY || '';
    const openaiApiKey = aiProvider === 'openai' ? apiKey : process.env.OPENAI_API_KEY || '';
    const claudeApiKey = aiProvider === 'claude' ? apiKey : process.env.CLAUDE_API_KEY || '';
    
    console.log('Layr Config Debug:', {
      selectedModel: this.aiModel,
      determinedProvider: aiProvider,
      apiKey: apiKey ? '***configured***' : 'not set'
    });
    
    return {
      aiProvider,
      geminiApiKey, // Keep for legacy support
      gemini: {
        apiKey: geminiApiKey,
        model: this.aiModel as any
      },
      openai: {
        apiKey: openaiApiKey,
        model: this.aiModel as any,
        organization: openaiOrganization
      },
      claude: {
        apiKey: claudeApiKey,
        model: this.aiModel as any
      }
    };
  }

  private initializeAIProvider(): void {
    console.log('Planner.initializeAIProvider: Starting AI provider initialization');
    console.log('Planner.initializeAIProvider: Selected model:', this.aiModel);
    console.log('Planner.initializeAIProvider: Determined provider:', this.config.aiProvider);
    
    try {
      const factory = getAIProviderFactory();
      const providerType = this.config.aiProvider || 'gemini';
      
      // Get provider-specific configuration
      let providerConfig: any;
      switch (providerType) {
        case 'gemini':
          providerConfig = {
            apiKey: this.config.gemini?.apiKey || '',
            model: this.aiModel
          };
          break;
        case 'openai':
          providerConfig = {
            apiKey: this.config.openai?.apiKey || '',
            model: this.aiModel,
            organization: this.config.openai?.organization
          };
          break;
        case 'claude':
          providerConfig = {
            apiKey: this.config.claude?.apiKey || '',
            model: this.aiModel
          };
          break;
        default:
          throw new Error(`Unsupported provider: ${providerType}`);
      }
      
      console.log('Planner.initializeAIProvider: Provider config:', { ...providerConfig, apiKey: providerConfig.apiKey ? '[REDACTED]' : 'MISSING' });
      
      this.aiProvider = factory.createProvider(providerType, providerConfig);
      console.log('Planner.initializeAIProvider: AI provider created successfully:', this.aiProvider.name);
    } catch (error) {
      console.log('Planner.initializeAIProvider: Failed to create AI provider:', error);
      this.aiProvider = null;
    }
  }

  private getApiKeyForProvider(): string {
    if (!this.aiProvider) return '';
    
    switch (this.aiProvider.type) {
      case 'gemini':
        return this.config.gemini?.apiKey || '';
      case 'openai':
        return this.config.openai?.apiKey || '';
      case 'claude':
        return this.config.claude?.apiKey || '';
      default:
        return '';
    }
  }

  private parseAIPlan(planText: string): ProjectPlan {
    console.log('Planner.parseAIPlan: Starting to parse AI response');
    console.log('Planner.parseAIPlan: Response length:', planText.length);
    
    try {
      // Try multiple JSON extraction methods
      let jsonText = '';
      
      // Method 1: Look for JSON between ```json and ``` markers
      const codeBlockMatch = planText.match(/```json\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch) {
        jsonText = codeBlockMatch[1].trim();
        console.log('Planner.parseAIPlan: Found JSON in code block');
      } else {
        // Method 2: Look for JSON between ``` and ``` markers (without json specifier)
        const genericCodeBlockMatch = planText.match(/```\s*([\s\S]*?)\s*```/);
        if (genericCodeBlockMatch) {
          const potentialJson = genericCodeBlockMatch[1].trim();
          if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {
            jsonText = potentialJson;
            console.log('Planner.parseAIPlan: Found JSON in generic code block');
          }
        }
        
        if (!jsonText) {
          // Method 3: Look for JSON object starting with { and ending with }
          const jsonMatch = planText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonText = jsonMatch[0];
            console.log('Planner.parseAIPlan: Found JSON object');
          } else {
            // Method 4: Try to parse the entire response as JSON
            try {
              JSON.parse(planText.trim());
              jsonText = planText.trim();
              console.log('Planner.parseAIPlan: Entire response is valid JSON');
            } catch {
              console.log('Planner.parseAIPlan: No valid JSON found in response');
              console.log('Planner.parseAIPlan: Full response for debugging:', planText);
              throw new Error('Invalid response format from AI service - no JSON found');
            }
          }
        }
      }

      console.log('Planner.parseAIPlan: Extracted JSON preview:', jsonText.substring(0, 200) + (jsonText.length > 200 ? '...' : ''));

      // Try to parse JSON with error handling and repair
      let planData;
      try {
        planData = JSON.parse(jsonText);
        console.log('Planner.parseAIPlan: Successfully parsed JSON');
      } catch (parseError) {
        console.log('Planner.parseAIPlan: JSON parse error:', parseError);
        console.log('Planner.parseAIPlan: Attempting to repair JSON...');
        
        // Try to repair common JSON issues
        let repairedJson = jsonText;
        
        // Fix trailing commas in arrays and objects
        repairedJson = repairedJson.replace(/,(\s*[}\]])/g, '$1');
        
        // Fix missing commas between array elements
        repairedJson = repairedJson.replace(/}(\s*){/g, '},$1{');
        repairedJson = repairedJson.replace(/](\s*)\[/g, '],$1[');
        
        // Fix missing quotes around property names
        repairedJson = repairedJson.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
        
        // Try parsing the repaired JSON
        try {
          planData = JSON.parse(repairedJson);
          console.log('Planner.parseAIPlan: Successfully repaired and parsed JSON');
        } catch (repairError) {
          console.log('Planner.parseAIPlan: Failed to repair JSON:', repairError);
          console.log('Planner.parseAIPlan: Original JSON for debugging:', jsonText);
          throw new Error('Failed to parse AI response as JSON');
        }
      }
      
      // Validate and transform the response
      const plan: ProjectPlan = {
        title: planData.title || 'Generated Project Plan',
        overview: planData.overview || 'No overview provided',
        requirements: Array.isArray(planData.requirements) ? planData.requirements : [],
        fileStructure: this.validateFileStructure(planData.fileStructure || []),
        nextSteps: this.validateNextSteps(planData.nextSteps || []),
        generatedAt: new Date(),
        generatedBy: 'ai'
      };

      console.log('Planner.parseAIPlan: Successfully created ProjectPlan object');
      return plan;
    } catch (error) {
      console.error('Planner.parseAIPlan: Failed to parse AI plan:', error);
      // Fallback to a basic plan structure
      return {
        title: 'AI Generated Plan',
        overview: planText.substring(0, 200) + '...',
        requirements: ['Review and refine the generated plan'],
        fileStructure: [],
        nextSteps: [
          {
            id: 'review',
            description: 'Review the AI-generated plan and make necessary adjustments',
            completed: false,
            priority: 'high' as const,
            estimatedTime: '30 minutes',
            dependencies: []
          }
        ],
        generatedAt: new Date(),
        generatedBy: 'ai' as const
      };
    }
  }

  private validateFileStructure(items: any[]): any[] {
    if (!Array.isArray(items)) return [];
    
    return items.map(item => ({
      name: item.name || 'unnamed',
      type: item.type === 'directory' ? 'directory' : 'file',
      description: item.description || '',
      children: item.children ? this.validateFileStructure(item.children) : []
    }));
  }

  private validateNextSteps(steps: any[]): any[] {
    if (!Array.isArray(steps)) return [];
    
    return steps.map((step, index) => ({
      id: step.id || `step-${index}`,
      description: step.description || 'No description',
      completed: false,
      priority: ['high', 'medium', 'low'].includes(step.priority) ? step.priority : 'medium',
      estimatedTime: step.estimatedTime || 'Unknown',
      dependencies: Array.isArray(step.dependencies) ? step.dependencies : []
    }));
  }
 
  private renderFileStructure(items: any[], markdown: string[], depth: number): void {
    const indent = '  '.repeat(depth);
    
    items.forEach(item => {
      const icon = item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
      const name = item.type === 'directory' ? `${item.name}/` : item.name;
      markdown.push(`${indent}${icon} ${name}`);
      
      if (item.children && item.children.length > 0) {
        this.renderFileStructure(item.children, markdown, depth + 1);
      }
    });
  }
}

// Export the main planner instance
export const planner = new Planner();

// Export types for use in extension
export * from './interfaces';