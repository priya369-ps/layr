import * as vscode from 'vscode';
import { ProjectPlan, LayrConfig, PlanGenerator, APIKeyMissingError, AIServiceError } from './interfaces';
import { GeminiPlanGenerator } from './ai';
import { RuleBasedPlanGenerator } from './rules';

/**
 * Main planner class that orchestrates plan generation
 */
export class Planner {
  private aiGenerator: GeminiPlanGenerator | null = null;
  private ruleGenerator: RuleBasedPlanGenerator;
  private config: LayrConfig;

  constructor() {
    // ONLINE ONLY MODE: Disable rule-based generator
    this.ruleGenerator = new RuleBasedPlanGenerator();
    this.config = this.loadConfig();
    this.initializeAIGenerator();
    
    console.log('Planner: ONLINE ONLY MODE - Offline templates disabled');
  }

  /**
   * Generate a project plan from a natural language prompt - ONLINE ONLY MODE
   */
  async generatePlan(prompt: string): Promise<ProjectPlan> {
    console.log('Planner.generatePlan: ONLINE ONLY MODE - Starting plan generation');
    
    // Force refresh config to ensure we have the latest API key
    this.refreshConfig();
    
    console.log('Planner.generatePlan: AI generator exists:', !!this.aiGenerator);
    console.log('Planner.generatePlan: Config API key:', this.config.geminiApiKey ? '***configured***' : 'not set');
    
    // REQUIRE AI generator - no offline fallback allowed
    if (!this.aiGenerator) {
      const errorMsg = 'ONLINE MODE REQUIRED: No AI generator initialized. Please configure your Gemini API key in VS Code settings or .env file.';
      console.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg);
      throw new APIKeyMissingError();
    }

    const isAvailable = await this.aiGenerator.isAvailable();
    console.log('Planner.generatePlan: AI generator available:', isAvailable);
    
    if (!isAvailable) {
      const errorMsg = 'ONLINE MODE REQUIRED: AI generator not available. Please check your Gemini API key configuration.';
      console.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg);
      throw new APIKeyMissingError();
    }

    try {
      console.log('Planner.generatePlan: Attempting AI plan generation');
      const plan = await this.aiGenerator.generatePlan(prompt);
      console.log('Planner.generatePlan: AI plan generation successful');
      vscode.window.showInformationMessage('Plan generated by Layr! ðŸ¤–');
      return plan;
    } catch (error) {
      console.error('Planner.generatePlan: AI plan generation failed:', error);
      
      let errorMessage = 'ONLINE MODE REQUIRED: AI plan generation failed. ';
      if (error instanceof APIKeyMissingError) {
        errorMessage += 'Please configure your Gemini API key.';
      } else if (error instanceof AIServiceError) {
        errorMessage += `AI service error: ${error.message}`;
      } else {
        errorMessage += 'Unexpected error with AI service.';
      }
      
      vscode.window.showErrorMessage(errorMessage);
      throw error; // Re-throw the error instead of falling back to offline mode
    }
  }

  /**
   * Convert a ProjectPlan to Markdown format
   */
  planToMarkdown(plan: ProjectPlan): string {
    const markdown = [];
    
    // Header
    markdown.push(`# ${plan.title}`);
    markdown.push('');
    markdown.push(`*Generated by Layr on ${plan.generatedAt.toLocaleDateString()} at ${plan.generatedAt.toLocaleTimeString()}*`);
    markdown.push('');

    // Overview
    markdown.push('## Overview');
    markdown.push(plan.overview);
    markdown.push('');

    // Requirements
    markdown.push('## Requirements');
    plan.requirements.forEach(req => {
      markdown.push(`- ${req}`);
    });
    markdown.push('');

    // File Structure
    markdown.push('## File Structure');
    markdown.push('```');
    this.renderFileStructure(plan.fileStructure, markdown, 0);
    markdown.push('```');
    markdown.push('');

    // Next Steps
    markdown.push('## Next Steps');
    plan.nextSteps.forEach((step, index) => {
      const checkbox = step.completed ? '[x]' : '[ ]';
      const priority = step.priority === 'high' ? 'ðŸ”´' : step.priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      const time = step.estimatedTime ? ` (${step.estimatedTime})` : '';
      markdown.push(`${index + 1}. ${checkbox} ${priority} ${step.description}${time}`);
      
      if (step.dependencies && step.dependencies.length > 0) {
        markdown.push(`   - *Depends on: ${step.dependencies.join(', ')}*`);
      }
    });
    markdown.push('');

    // Footer
    markdown.push('---');
    markdown.push('*Generated by Layr - AI Planning Layer for VS Code*');

    return markdown.join('\n');
  }

  /**
   * Refresh configuration and reinitialize AI generator
   */
  refreshConfig(): void {
    this.config = this.loadConfig();
    this.initializeAIGenerator();
  }

  /**
   * Debug method to check if AI generator is available
   */
  async isAIAvailable(): Promise<boolean> {
    return this.aiGenerator !== null && await this.aiGenerator.isAvailable();
  }

  /**
   * Debug method to test the API key
   */
  async testAPIKey(): Promise<{ success: boolean; error?: string }> {
    if (!this.aiGenerator) {
      return { success: false, error: 'AI generator not initialized' };
    }
    return await this.aiGenerator.testApiKey();
  }

  private loadConfig(): LayrConfig {
    const config = vscode.workspace.getConfiguration('layr');
    const settingsApiKey = config.get<string>('geminiApiKey') || '';
    const envApiKey = process.env.GEMINI_API_KEY || '';
    const apiKey = settingsApiKey || envApiKey;
    
    console.log('Layr Config Debug:', {
      settingsApiKey: settingsApiKey ? '***configured***' : 'not set',
      envApiKey: envApiKey ? '***configured***' : 'not set',
      finalApiKey: apiKey ? '***configured***' : 'not set'
    });
    
    return {
      geminiApiKey: apiKey
    };
  }

  private initializeAIGenerator(): void {
    console.log('Planner.initializeAIGenerator: Starting AI generator initialization');
    console.log('Planner.initializeAIGenerator: API key available:', !!this.config.geminiApiKey);
    console.log('Planner.initializeAIGenerator: API key length:', this.config.geminiApiKey?.length || 0);
    
    if (this.config.geminiApiKey && this.config.geminiApiKey.trim() !== '' && this.config.geminiApiKey !== 'your_api_key_here') {
      console.log('Planner.initializeAIGenerator: Creating GeminiPlanGenerator');
      this.aiGenerator = new GeminiPlanGenerator(this.config.geminiApiKey);
      console.log('Planner.initializeAIGenerator: AI generator created successfully');
    } else {
      console.log('Planner.initializeAIGenerator: Invalid or missing API key, AI generator not initialized');
      this.aiGenerator = null;
    }
  }

  private renderFileStructure(items: any[], markdown: string[], depth: number): void {
    const indent = '  '.repeat(depth);
    
    items.forEach(item => {
      const icon = item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
      const name = item.type === 'directory' ? `${item.name}/` : item.name;
      markdown.push(`${indent}${icon} ${name}`);
      
      if (item.children && item.children.length > 0) {
        this.renderFileStructure(item.children, markdown, depth + 1);
      }
    });
  }
}

// Export the main planner instance
export const planner = new Planner();

// Export types for use in extension
export * from './interfaces';