/**
 * Supported AI providers
 */
export type AIProviderType = 'gemini' | 'openai' | 'claude';

/**
 * Configuration interface for the Layr extension
 */
export interface LayrConfig {
  // Legacy support
  geminiApiKey?: string;
  
  // New multi-provider configuration
  aiProvider?: AIProviderType;
  gemini?: GeminiConfig;
  openai?: OpenAIConfig;
  claude?: ClaudeConfig;
}

/**
 * Gemini AI configuration
 */
export interface GeminiConfig {
  apiKey: string;
  model?: 'gemini-2.5-flash' | 'gemini-2.5-pro' | 'gemini-pro' | 'gemini-pro-vision';
}

/**
 * OpenAI configuration
 */
export interface OpenAIConfig {
  apiKey: string;
  model?: 'gpt-4' | 'gpt-4-turbo' | 'gpt-3.5-turbo';
  organization?: string;
}

/**
 * Claude AI configuration
 */
export interface ClaudeConfig {
  apiKey: string;
  model?: 'claude-3-opus' | 'claude-3-sonnet' | 'claude-3-haiku';
}

/**
 * Represents a project plan generated by the AI or rule-based system
 */
export interface ProjectPlan {
  title: string;
  overview: string;
  requirements: string[];
  fileStructure: FileStructureItem[];
  nextSteps: PlanStep[];
  generatedAt: Date;
  generatedBy: 'ai' | 'rules';
}

/**
 * Represents a file or directory in the project structure
 */
export interface FileStructureItem {
  name: string;
  type: 'file' | 'directory';
  path: string;
  description?: string;
  children?: FileStructureItem[];
}

/**
 * Represents a step in the project plan
 */
export interface PlanStep {
  id: string;
  description: string;
  completed: boolean;
  priority: 'high' | 'medium' | 'low';
  estimatedTime?: string;
  dependencies?: string[];
}

/**
 * Interface for AI providers
 */
export interface AIProvider {
  readonly name: string;
  readonly type: AIProviderType;
  
  generatePlan(prompt: string, options?: any): Promise<string>;
  validateApiKey(apiKey: string): Promise<boolean>;
  getSupportedModels(): string[];
  isAvailable(): Promise<boolean>;
}

/**
 * Interface for plan generators (AI or rule-based)
 */
export interface PlanGenerator {
  generatePlan(prompt: string): Promise<ProjectPlan>;
  isAvailable(): Promise<boolean>;
}

/**
 * AI provider factory interface
 */
export interface AIProviderFactory {
  createProvider(type: AIProviderType, config: any): AIProvider;
  getSupportedProviders(): AIProviderType[];
}

/**
 * Template for rule-based plan generation
 */
export interface PlanTemplate {
  keywords: string[];
  title: string;
  overview: string;
  requirements: string[];
  fileStructure: FileStructureItem[];
  nextSteps: PlanStep[];
}

/**
 * Error types for plan generation
 */
export class PlanGenerationError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'PlanGenerationError';
  }
}

export class APIKeyMissingError extends PlanGenerationError {
  constructor(provider?: AIProviderType) {
    const providerName = provider ? provider.charAt(0).toUpperCase() + provider.slice(1) : 'AI';
    super(`${providerName} API key is missing. Please configure it in settings or .env file.`);
    this.name = 'APIKeyMissingError';
  }
}

export class UnsupportedProviderError extends PlanGenerationError {
  constructor(provider: string) {
    super(`Unsupported AI provider: ${provider}. Supported providers: gemini, openai, claude.`);
    this.name = 'UnsupportedProviderError';
  }
}

export class AIServiceError extends PlanGenerationError {
  constructor(message: string, cause?: Error) {
    super(`AI service error: ${message}`, cause);
    this.name = 'AIServiceError';
  }
}